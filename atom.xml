<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>发现新大陆</title>
  
  <subtitle>冷静，坚持，心得体会</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://caixw.cn/"/>
  <updated>2019-12-28T09:43:50.027Z</updated>
  <id>http://caixw.cn/</id>
  
  <author>
    <name>William Cai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Error creating bean with name &#39;eurekaAutoServiceRegistration&#39;的原因分析</title>
    <link href="http://caixw.cn/2019/12/28/2019122801/"/>
    <id>http://caixw.cn/2019/12/28/2019122801/</id>
    <published>2019-12-28T09:17:09.000Z</published>
    <updated>2019-12-28T09:43:50.027Z</updated>
    
    <content type="html"><![CDATA[<p>启动微服务的时候，突然报这个服务，错误如下：</p><p><code>org.springframework.beans.factory.BeanCreationNotAllowedException: Error creating bean with name ‘eurekaAutoServiceRegistration’: Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)</code><br>有如下原因如下：<br> (1) 同一个服务重复启动了；<br>（2）端口被其他应用占用了；</p><p>解决办法：<br>（1）参考<a href="http://www.itersblog.com/archives/29.html；" target="_blank" rel="noopener">http://www.itersblog.com/archives/29.html；</a><br>（2）<a href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1952#issuecomment-355487342" target="_blank" rel="noopener">https://github.com/spring-cloud/spring-cloud-netflix/issues/1952#issuecomment-355487342</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;启动微服务的时候，突然报这个服务，错误如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.springframework.beans.factory.BeanCreationNotAllowedException: Error creating bean with name ‘eur
      
    
    </summary>
    
    
      <category term="技术研究" scheme="http://caixw.cn/tags/%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6/"/>
    
  </entry>
  
  <entry>
    <title>2019121601</title>
    <link href="http://caixw.cn/2019/12/16/2019121601/"/>
    <id>http://caixw.cn/2019/12/16/2019121601/</id>
    <published>2019-12-16T03:19:41.000Z</published>
    <updated>2019-12-16T14:05:27.479Z</updated>
    
    <content type="html"><![CDATA[<p>项目管理协会(PMI)定制了项目管理知识体系的图表和词汇标准；<br>知识体系 (BOK) 包括已发布和未发布的材料，这一知识体系仍在不断演变发展；<br>本《PMBOK®指南》 收录项目管理知识体系中被普遍认可为“良好实践”的那一部分；<br>本指南基于《项目管理标准》；<br>本指南的范围仅限于项目管理领域，而不涉及任何项目组合、项目集和多个项目的领域；<br>通用词汇是专业学科的基本要素。<br>全球项目管理业界定义的最重要的价值 观是责任、尊重、公正和诚实，这是《道德与专业行为规范》的最重要的规范；<br>项目是为创造独特的产品、服务或成果而进行的临时性工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目管理协会(PMI)定制了项目管理知识体系的图表和词汇标准；&lt;br&gt;知识体系 (BOK) 包括已发布和未发布的材料，这一知识体系仍在不断演变发展；&lt;br&gt;本《PMBOK®指南》 收录项目管理知识体系中被普遍认可为“良好实践”的那一部分；&lt;br&gt;本指南基于《项目管理标准》；
      
    
    </summary>
    
    
      <category term="技术" scheme="http://caixw.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>https的简单使用</title>
    <link href="http://caixw.cn/2019/12/11/20191211/"/>
    <id>http://caixw.cn/2019/12/11/20191211/</id>
    <published>2019-12-11T11:22:02.000Z</published>
    <updated>2019-12-14T02:34:55.120Z</updated>
    
    <content type="html"><![CDATA[<p>1、https与http的区别<br>https相比http 多了一安全Security层，双方的传输通过对称加密传输；传输的数据不被窃取和篡改；</p><p>2、https的实现原理</p><p> (1) 客户向服务端发送一个空的https请求；服务端返回CA证书（包含有公钥）；<br>（2）客户端验证CA证书的有效性，如果有效，执行下一步；<br>（3）客户端生成一个随机数；通过公钥加密这个随机数，发送给服务端；<br>（4）服务端通过公钥对应的私钥解密获取随机数；<br>（5）服务端和客户端通过这个随机数的对称加密传输数据；</p><p>3、由http 切换到https<br>  (1) nginx重定向</p><pre><code>` server {  listen  80;server_name docs.lvrui.iorewrite ^(.*)$  https://$host$1 permanent; # return 302 https://$host$request_uri; }server {listen 443 ssl;server_name docs.lvrui.io;index index.html index.htm;access_log  /var/log/nginx/docs.log  main;ssl on;ssl_certificate /etc/ssl/docs.20150509.cn.crt;ssl_certificate_key  /etc/ssl/docs.20150509.cn.key;error_page 404 /404.html;location / {    root /var/www/html/docs;} }</code></pre><p>`</p><p>（2）index刷新重定向</p><pre><code> &lt;html&gt;  &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=https://docs.lvrui.io/&quot;&gt; &lt;/html&gt;    server {listen 80;server_name docs.lvrui.io;location / {    # 将 index.html 文件放到下面的目录下    root /var/www/html/refresh/;} }server {listen 443 ssl;server_name docs.lvrui.io;index index.html index.htm;access_log  /var/log/nginx/docs.log  main;ssl on;ssl_certificate /etc/ssl/docs.20150509.cn.crt;ssl_certificate_key  /etc/ssl/docs.20150509.cn.key;error_page 404 /404.html;location / {    root /var/www/html/docs;} }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、https与http的区别&lt;br&gt;https相比http 多了一安全Security层，双方的传输通过对称加密传输；传输的数据不被窃取和篡改；&lt;/p&gt;
&lt;p&gt;2、https的实现原理&lt;/p&gt;
&lt;p&gt; (1) 客户向服务端发送一个空的https请求；服务端返回CA证书（包
      
    
    </summary>
    
    
      <category term="技术" scheme="http://caixw.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>2019120201</title>
    <link href="http://caixw.cn/2019/12/02/2019120201/"/>
    <id>http://caixw.cn/2019/12/02/2019120201/</id>
    <published>2019-12-01T23:58:36.000Z</published>
    <updated>2019-12-02T03:52:05.654Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nacos-的初探"><a href="#nacos-的初探" class="headerlink" title="nacos 的初探"></a>nacos 的初探</h2><h3 id="1、为什么要使用nacos"><a href="#1、为什么要使用nacos" class="headerlink" title="1、为什么要使用nacos"></a>1、为什么要使用nacos</h3><p>(1) eureka服务从2.0开始不在维护了，后期升级和维护困难;<br>(2) nocos支持的服务更多，包括基于DNS和基于RPC的服务，提供实时的健康检查；<br>(3) 更适应于云服务架构，支持多租户和多环境；</p><h3 id="2、服务发现"><a href="#2、服务发现" class="headerlink" title="2、服务发现"></a>2、服务发现</h3><p>   Dynamic Service Discovery is key to service-centric (for example microservice or cloud-native) architectures. Nacos supports both DNS-based and RPC-based (Dubbo, gRPC) service discovery, and provides real-time service health checks to prevent routing requests from being sent to unhealthy hosts or service instances. With Nacos, you can also implement circuit breakers for your services with ease.</p><h3 id="3、服务配置"><a href="#3、服务配置" class="headerlink" title="3、服务配置"></a>3、服务配置</h3><p>Dynamic Configuration Service allows you to manage configurations in all environments in a centralized, externalized, and dynamic approach. Dynamic configuration saves you from redeploying your applications and services when configuration is updated. You can implement stateless services and achieve on-demand scaling effortlessly.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;nacos-的初探&quot;&gt;&lt;a href=&quot;#nacos-的初探&quot; class=&quot;headerlink&quot; title=&quot;nacos 的初探&quot;&gt;&lt;/a&gt;nacos 的初探&lt;/h2&gt;&lt;h3 id=&quot;1、为什么要使用nacos&quot;&gt;&lt;a href=&quot;#1、为什么要使用naco
      
    
    </summary>
    
    
      <category term="技术" scheme="http://caixw.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>20191126</title>
    <link href="http://caixw.cn/2019/11/26/20191126/"/>
    <id>http://caixw.cn/2019/11/26/20191126/</id>
    <published>2019-11-26T15:36:47.000Z</published>
    <updated>2019-11-27T06:32:22.557Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于Linux的定时更新时间配置"><a href="#关于Linux的定时更新时间配置" class="headerlink" title="关于Linux的定时更新时间配置"></a>关于Linux的定时更新时间配置</h3><p>1、直接命令：crontab -e====<br>2、vim /etc/crontab<br>加入配置：<code>*/1 * * * *  /usr/sbin/ntpdate 0.asia.pool.ntp.org</code><br>3、为了开机自启动，命令：vim /etc/rc.d/rc.local 加入以上命令</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于Linux的定时更新时间配置&quot;&gt;&lt;a href=&quot;#关于Linux的定时更新时间配置&quot; class=&quot;headerlink&quot; title=&quot;关于Linux的定时更新时间配置&quot;&gt;&lt;/a&gt;关于Linux的定时更新时间配置&lt;/h3&gt;&lt;p&gt;1、直接命令：crontab
      
    
    </summary>
    
    
      <category term="技术" scheme="http://caixw.cn/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>认识spring</title>
    <link href="http://caixw.cn/2019/11/22/2019112201/"/>
    <id>http://caixw.cn/2019/11/22/2019112201/</id>
    <published>2019-11-22T03:40:31.000Z</published>
    <updated>2019-11-22T15:52:38.213Z</updated>
    
    <content type="html"><![CDATA[<h3 id="spring的发展"><a href="#spring的发展" class="headerlink" title="spring的发展"></a>spring的发展</h3><p>spring 作为java服务器端开发的事实标准，有着巨大的优势，他对标的是EJB,为开发企业级应用提供一站式解决方案，核心思想是对象之间的依赖管理由容器来管理，为此其核心技术是bean 容器，ioc和aop。为了简化对spring 的使用，springboot ,它简化了配置，只需很少的处理就可以运行微服务，达到开箱即用的效果。为了更好的开发分布式应用，spring cloud应运而生，它集合了注册和发现，服务熔断和负载均衡等核心组件；万物互联等时代开始来临，Spring cloud data flow 目标是connect anything。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;spring的发展&quot;&gt;&lt;a href=&quot;#spring的发展&quot; class=&quot;headerlink&quot; title=&quot;spring的发展&quot;&gt;&lt;/a&gt;spring的发展&lt;/h3&gt;&lt;p&gt;spring 作为java服务器端开发的事实标准，有着巨大的优势，他对标的是EJB,
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://caixw.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>diskpart的使用</title>
    <link href="http://caixw.cn/2019/09/03/2019090301/"/>
    <id>http://caixw.cn/2019/09/03/2019090301/</id>
    <published>2019-09-03T14:17:45.000Z</published>
    <updated>2019-09-03T14:35:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mount-a-disk-to-another-disk"><a href="#mount-a-disk-to-another-disk" class="headerlink" title="mount a disk to  another disk"></a>mount a disk to  another disk</h3><pre><code>&gt; diskpart&gt; list vol  /*list all volume*/&gt; select vol=3&gt; remove &gt; assign mount=c:\mnt   /*vol=3 mount to c:\mnt*/</code></pre><h3 id="remove-mount"><a href="#remove-mount" class="headerlink" title="remove mount"></a>remove mount</h3><pre><code>&gt; diskpart&gt; list vol&gt; remove mount=c:\mnt&gt; select vol=3&gt; assign mount=f:</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mount-a-disk-to-another-disk&quot;&gt;&lt;a href=&quot;#mount-a-disk-to-another-disk&quot; class=&quot;headerlink&quot; title=&quot;mount a disk to  another disk&quot;&gt;&lt;/a&gt;m
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>springboot调度任务</title>
    <link href="http://caixw.cn/2019/03/24/2019032402/"/>
    <id>http://caixw.cn/2019/03/24/2019032402/</id>
    <published>2019-03-24T08:39:30.000Z</published>
    <updated>2019-03-24T13:35:46.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>基于注解配置</li></ul><p>-</p><pre><code>@EnableScheduling  开启调度@EnableAsync       开启异步线程public class EnvironmentTestController {/@Scheduled(cron = &quot;*/5 * * * * ?&quot;) 单位为毫秒数@Scheduled(fixedRate = 5000) 可以设置固定间隔毫秒数@Async        开启多个任务的时候，多个线程处理public  void printCount(){    System.out.println(Thread.currentThread().getName());    //System.out.println(&quot;Count:&quot;+Count);}}</code></pre><ul><li>cron 表达式</li></ul><p>Cron表达式参数分别表示：</p><p>秒（0~59） 例如0/5表示从零开始，每隔5秒<br>分（0~59）<br>时（0~23）<br>日（0~31）的某天，需计算<br>月（0~11）<br>周几（ 可填1-7 或 SUN/MON/TUE/WED/THU/FRI/SAT）<br><em>表示任意<br>？表示不确定<br>n/m 表示从n开始，每隔m<br>@Scheduled：除了支持灵活的参数表达式cron之外，还支持简单的延时操作，例如 fixedDelay ，fixedRate 填写相应的毫秒数即可。<br>每隔一分钟： </em> 0/1 <em> </em> * ？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;基于注解配置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@EnableScheduling  开启调度
@EnableAsync       开启异步线程
public class EnvironmentTestController {

/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jconsole 查看springboot 项目</title>
    <link href="http://caixw.cn/2019/03/24/2019032401/"/>
    <id>http://caixw.cn/2019/03/24/2019032401/</id>
    <published>2019-03-24T01:19:11.000Z</published>
    <updated>2019-03-24T01:41:50.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>需要在启动参数里配置如下：</li><li><p> -Dcom.sun.management.jmxremote.authenticate=”false”<br> -Dcom.sun.management.jmxremote.ssl=”false”<br> -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=”6017”</p></li></ul><ul><li><p>ctrl+r启动 jconsole ,如下图所示：</p><p>– 登录界面</p><p><img src="/assets/blogImg/jconsole_login.JPG" alt="jconsole_login"></p></li></ul><p> – 登录后的面板</p><p> <img src="/assets/blogImg/jconsole_board.JPG" alt="jconsole_board"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;需要在启动参数里配置如下：&lt;/li&gt;
&lt;li&gt;&lt;p&gt; -Dcom.sun.management.jmxremote.authenticate=”false”&lt;br&gt; -Dcom.sun.management.jmxremote.ssl=”false”&lt;br&gt; -
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://caixw.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>读《深入理解Java虚拟机》有感之4</title>
    <link href="http://caixw.cn/2019/02/20/20190220love/"/>
    <id>http://caixw.cn/2019/02/20/20190220love/</id>
    <published>2019-02-20T11:50:05.000Z</published>
    <updated>2019-02-20T15:09:48.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>对象的创建</li></ul><p>（1）虚拟机遇到new的指令时，首先从常量池查看是否有类的常量符号引用，并且检查这个符号引用代表的类是否已经加载，解析和初始化过，如果没有的话，就会启动类的加载。在类加载检查通过后，接下来虚拟机为新生的对象分配内存，分配内存的过程就是在堆中划分一块内存出来。为了加快对象的内存分配，防止指针的不安全，通常是使用TLAB（本地线程缓冲），可以使用参数-XX:+UseTLAB设置。</p><p>（2）内存分配完成后，虚拟机需要保证将分配的内存空间都设置为零值（不包括对象头），这样即使没有初始化，也可以访问数据为零值；</p><p>（3）接下来要是设置对象头，对象头内容有：元数据信息，对象的哈希码，对象的GC分代年龄等信息；</p><p>（4）在上面完成之后，一个新的对象产生了，但是还没有init(),所有字段值为零；初始化之后就有值；</p><ul><li>对象的布局</li></ul><p>对象布局可以分为3部分：对象头，实例数据和对齐填充；<br>（1） 对象头：一个为Mark world:hash,gc年代等数据，一个为类的指针，确定这个对象为那个类型的实例；如果是数组的话，还有一个字段存储数组长度；<br>（2）实例数据，无论是从父类继承下来的，还是在子类中定义的，都需要记录起来；这部分存储顺序收到分配策略影响，Hotspot虚拟机默认的策略是相同宽度的字段总是被分配到一起，在此基础之上父类的字段出现在子类之前；</p><p>（3）对象填充并不是必然存在的，也没有特殊的含义，只是起着占位符的作用，由于HotspotVM 内存管理系统的要求对象的起始地址必须是8字节倍数；所以没有对齐的，就需要补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;对象的创建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（1）虚拟机遇到new的指令时，首先从常量池查看是否有类的常量符号引用，并且检查这个符号引用代表的类是否已经加载，解析和初始化过，如果没有的话，就会启动类的加载。在类加载检查通过后，接下来虚拟机为新生的对象分配内存，分配内
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://caixw.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>读《深入理解Java虚拟机》有感之3</title>
    <link href="http://caixw.cn/2019/02/14/20190214love/"/>
    <id>http://caixw.cn/2019/02/14/20190214love/</id>
    <published>2019-02-14T14:52:09.000Z</published>
    <updated>2019-02-14T15:15:14.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>虚拟机栈</p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p></li><li><p>本地方法栈</p></li></ul><p>其作用与虚拟机栈基本相似，区别是虚拟机栈为虚拟机执行java方法服务，二本地方法栈则为虚拟机使用到Native方法服务；与虚拟机方法栈一样，本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。</p><ul><li>Java 堆</li></ul><p>Java堆主要为类和数组实例分配内存；如果堆是可以扩展的，如果堆中没有内存分配，并且堆也无法扩展时，将会抛出OutOfMemoryError异常；</p><ul><li>方法区</li></ul><p>该区又称”永久代”，主要存储已被虚拟机加载的类信息，常量，静态变量，JIT编译后的代码等数据。当方法区无法完成内存分配要求，也将抛出<br>OutOfMemoryError异常。</p><ul><li>运行时常量池</li></ul><p>运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。既然运行时常量池是方法区的一部分，自然就会收到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p><ul><li>直接内存</li></ul><p>直接内存是jvm之外的内存，受到本机内存的限制，如果分配的内存无法满足时，就会抛出OutOfMemoryError异常。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;虚拟机栈&lt;/p&gt;
&lt;p&gt;如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://caixw.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>读《深入理解Java虚拟机有感》之2</title>
    <link href="http://caixw.cn/2019/02/12/20190212love/"/>
    <id>http://caixw.cn/2019/02/12/20190212love/</id>
    <published>2019-02-12T14:21:29.000Z</published>
    <updated>2019-02-12T14:30:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>java把内存的分配和回收交给了虚拟机，工程师不用自己手动释放内存，这样就带来了一个不好的事情，一旦发生内存异常和溢出，如果对jvm<br>内存原理不够精通的话，排查问题就是一件痛苦的工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java把内存的分配和回收交给了虚拟机，工程师不用自己手动释放内存，这样就带来了一个不好的事情，一旦发生内存异常和溢出，如果对jvm&lt;br&gt;内存原理不够精通的话，排查问题就是一件痛苦的工作。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随笔" scheme="http://caixw.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>读《深入理解Java虚拟机有感》之1</title>
    <link href="http://caixw.cn/2019/02/11/20190211love/"/>
    <id>http://caixw.cn/2019/02/11/20190211love/</id>
    <published>2019-02-11T13:33:58.000Z</published>
    <updated>2019-02-12T12:39:04.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>理解java虚拟机的理由</li></ul><p>   (1) 理解jvm运行原理，可以编写高质量的代码。</p><p>   (2) jvm 接管了内存，好处是可以不用担心内存释放的问题，但是出现内存泄漏的情况，就必须<br>   深入理解jvm,才能更好的定位和解决问题。</p><p>   (3) jvm 未来朝着模块化和支持多核方向发展，编写lamda函数式编程可以更好的支持多核，理解jvm<br>   有助于知其然，知其所以然。</p><p>   (4) 目前显卡的算术运算能力，并行能力已经远远超过了CPU，在图形领域以外发掘显卡的潜力是近几年计算机发展的方向之一。Java的项目Sumatra就是提供GPU和APU运算能力的工具，以后她将直接提供java语言层面的API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;理解java虚拟机的理由&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;   (1) 理解jvm运行原理，可以编写高质量的代码。&lt;/p&gt;
&lt;p&gt;   (2) jvm 接管了内存，好处是可以不用担心内存释放的问题，但是出现内存泄漏的情况，就必须&lt;br&gt;   深入理解jvm,才能更好
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://caixw.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>经典老歌，久听不厌</title>
    <link href="http://caixw.cn/2019/01/10/jingdianlaogefor20190110/"/>
    <id>http://caixw.cn/2019/01/10/jingdianlaogefor20190110/</id>
    <published>2019-01-10T13:48:11.000Z</published>
    <updated>2019-01-10T14:00:52.000Z</updated>
    
    <content type="html"><![CDATA[  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="600" height="450" src="//music.163.com/outchain/player?type=0&id=988690134&auto=1&height=430"></iframe>]]></content>
    
    <summary type="html">
    
      
      
          &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;600&quot; height=&quot;450&quot; src=&quot;//music.163.com/outchain/player?type=0&amp;
      
    
    </summary>
    
    
      <category term="随笔" scheme="http://caixw.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>读《从0开始学架构》有感-开篇</title>
    <link href="http://caixw.cn/2018/06/24/2018062401/"/>
    <id>http://caixw.cn/2018/06/24/2018062401/</id>
    <published>2018-06-24T07:50:51.000Z</published>
    <updated>2018-06-24T08:49:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>每个人程序员都有一个架构师梦想，但是梦想是美好的，现实却是残酷的。</p><h1 id="架构没有想象中的简单，它有几个特性："><a href="#架构没有想象中的简单，它有几个特性：" class="headerlink" title="架构没有想象中的简单，它有几个特性："></a>架构没有想象中的简单，它有几个特性：</h1><h2 id="1、架构设计的思维和程序设计的思维差异很大"><a href="#1、架构设计的思维和程序设计的思维差异很大" class="headerlink" title="1、架构设计的思维和程序设计的思维差异很大"></a>1、架构设计的思维和程序设计的思维差异很大</h2><ul><li>架构设计的关键思维是判断和取舍，程序设计的关键思维是逻辑与实现。要从程序员转变成架构师，就必须转变思维；同理穷人和富人的思维也不同，要成为富人必须有富人的思维。</li></ul><h2 id="2、架构设计没有体系化的培训和训练机制"><a href="#2、架构设计没有体系化的培训和训练机制" class="headerlink" title="2、架构设计没有体系化的培训和训练机制"></a>2、架构设计没有体系化的培训和训练机制</h2><ul><li>大学几乎没有架构设计的相关课程，也没有体系化的相关书籍，只能依靠自己摸索，效率低，容易采坑。</li></ul><h2 id="3、程序员对架构设计存在很大误区"><a href="#3、程序员对架构设计存在很大误区" class="headerlink" title="3、程序员对架构设计存在很大误区"></a>3、程序员对架构设计存在很大误区</h2><ul><li>要成为架构师必须要有很强的技术天分；架构师要有很强的创造力；架构设计必须要高大上才能体现架构师设计能力；架构一定要具备高可用、高性能…这些似似而非的误区。</li></ul><h1 id="通过学习《从0开始学习架构》，我可以收获："><a href="#通过学习《从0开始学习架构》，我可以收获：" class="headerlink" title="通过学习《从0开始学习架构》，我可以收获："></a>通过学习《从0开始学习架构》，我可以收获：</h1><ul><li>清楚的理解架构设计的本质、概念、目的，避免架构师在实践过程中把握不住重点、分不清主次，眉毛胡子一把抓，导致架构设计的四不像。</li><li>掌握架构设计的通用原则，无论何种业务或技术，架构师在判断和选择的时候有一套方法论可以参考，避免架构设计举棋不定，或者拍脑袋式设计。</li><li>掌握标准的架构设计流程，即使是刚开始做技术架构，也能够按照架构一步一步设计出合适的架构，避免某些步骤缺失导致错误的架构设计。</li><li>深入理解已有的架构模式，做到架构特点快速挑选合适的模式完成架构设计，或者在已有的模式上进行创新，或者将已有的模式组合出新的架构。</li><li>掌握架构演进和开源系统使用的一些技巧。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每个人程序员都有一个架构师梦想，但是梦想是美好的，现实却是残酷的。&lt;/p&gt;
&lt;h1 id=&quot;架构没有想象中的简单，它有几个特性：&quot;&gt;&lt;a href=&quot;#架构没有想象中的简单，它有几个特性：&quot; class=&quot;headerlink&quot; title=&quot;架构没有想象中的简单，它有几个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分库分表总结</title>
    <link href="http://caixw.cn/2018/06/17/201806171029/"/>
    <id>http://caixw.cn/2018/06/17/201806171029/</id>
    <published>2018-06-17T02:29:37.000Z</published>
    <updated>2018-06-17T02:52:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h2><p>当存储数据过多，性能下降，无法满足正常的业务需求的时候，就需要将单个空间拆分成多个，分担单个个体的压力，缩短响应时间，提高性能。<br>分库分表，顾名思义，是两个操作。<br>分库，拆分成多个数据库，分表，拆分成多张表。<br>常见方式有：单库单表-&gt;单库多表-&gt;多库多表。</p><h2 id="如何进行数据拆分"><a href="#如何进行数据拆分" class="headerlink" title="如何进行数据拆分"></a>如何进行数据拆分</h2><p>最简单的方式就是按照ID将数据分配到不同的库不同的表中。<br>当你创建一条记录时，就会根据生成的ID计算这条数据放到哪个库哪张表里去。</p><h2 id="分库分表路由规则"><a href="#分库分表路由规则" class="headerlink" title="分库分表路由规则"></a>分库分表路由规则</h2><p>假如有16个库（从00库到15库），每个库有64张表，那一共就是有1024张表（从0000-1023）<br>对应的路由规则：<br>dbRule=id%1024%64<br>tbRule=id%1024<br>那么对应的库为dbName_dbRule<br>对应的表为：tbName_tbRule</p><h3 id="常见的方式"><a href="#常见的方式" class="headerlink" title="常见的方式"></a>常见的方式</h3><ul><li>简单ID取模</li><li>字符串hash取模</li></ul><h2 id="分表键的问题"><a href="#分表键的问题" class="headerlink" title="分表键的问题"></a>分表键的问题</h2><p>选择谁作为分表键，这涉及到数据库的可扩展性，是否便于查询，能够避免跨库事务等，如果数据老是落到特定的数据库表中，那就分库分表就没有意义了。<br>这个问题没有明确的答案，必须根据实际业务来确定。建议分表键尽可能找到数据表中的数据在业务逻辑上的主体，并确定大部分的数据库围绕这个主体的数据进行。如果一个分表键无法解决，可以使用2个，尽量越少越好。</p><h2 id="分库分表存在的问题"><a href="#分库分表存在的问题" class="headerlink" title="分库分表存在的问题"></a>分库分表存在的问题</h2><ul><li>数据按照用户划分，就会造成跨库事务问题。</li><li>原来所有的单库单表的sql都要进行改造，加入appId分表键。</li><li>汇总分库分表的数据，要跨越多个库，是一个问题。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么要分库分表&quot;&gt;&lt;a href=&quot;#为什么要分库分表&quot; class=&quot;headerlink&quot; title=&quot;为什么要分库分表&quot;&gt;&lt;/a&gt;为什么要分库分表&lt;/h2&gt;&lt;p&gt;当存储数据过多，性能下降，无法满足正常的业务需求的时候，就需要将单个空间拆分成多个，分担单个
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Git的简单使用</title>
    <link href="http://caixw.cn/2018/06/04/20180604/"/>
    <id>http://caixw.cn/2018/06/04/20180604/</id>
    <published>2018-06-04T14:43:16.000Z</published>
    <updated>2018-06-04T15:07:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>###如果没有初始化的项目，可以通过以下步骤：</p><pre><code>$echo &quot;# kotlinPrimary&quot; &gt;&gt; README.md$git init$git add README.md$git commit -m &quot;first commit&quot;$git remote add origin git@github.com:williamcai663/$kotlinPrimary.git$git push -u origin master</code></pre><p>这样就可以把项目推到库中并生成且提交到master</p><p>###如果存在一个库的项目，直接执行如下命令：<br>    $git remote add origin <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:williamcai663/kotlinPrimary.git<br>    $git push -u origin master</p><p>###如果想从master上开一个develop分支，可以执行如下：<br>    $git checkout -b develop<br>-b 的作用就是创建并切换到develop分支<br>这个新开的分支并没有关联到远程分支，创建远程分支并提交到远程，执行 git push origin develop<br>这样远程就有了一个分支，并且与远程的分支develop没有关联上，<br>可以通过执行如下命令：</p><pre><code>$git branch --set-upstream-to=origin/develop develop</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###如果没有初始化的项目，可以通过以下步骤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$echo &amp;quot;# kotlinPrimary&amp;quot; &amp;gt;&amp;gt; README.md
$git init
$git add README.md
$git commit -m &amp;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ubuntu搭建elasticsearch和使用</title>
    <link href="http://caixw.cn/2018/05/06/20180506elasticsearch/"/>
    <id>http://caixw.cn/2018/05/06/20180506elasticsearch/</id>
    <published>2018-05-06T06:53:26.000Z</published>
    <updated>2018-05-06T14:58:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>參考 ：<a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;參考 ：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.ruanyifeng.com/blog/201
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>elasticsearch的安裝</title>
    <link href="http://caixw.cn/2018/05/05/20180505elasticsearch/"/>
    <id>http://caixw.cn/2018/05/05/20180505elasticsearch/</id>
    <published>2018-05-05T13:58:46.000Z</published>
    <updated>2018-05-05T14:40:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>– 1.检查jdk安装</p><p>执行命令：java -version<br>如果有java相关信息，说明已经安装。<br>如果没有安装的话，执行命令：yum -y install  java-1.8.0-openjdk<br>– 2.下载elasticsearch安装包</p><p>执行命令：</p><pre><code>wget https://download.elastic.co/elasticsearch/release/org/elasticsearch/distribution/tar/elasticsearch/2.3.4/elasticsearch-2.3.4.tar.gz</code></pre><p>– 3.解压和配置elasticsearch</p><p>解压执行：tar -zxvf elasticsearch-2.3.4.tar.gz<br>执行：cd elasticsearch-2.3.4 &amp;&amp; cd bin &amp;&amp; ./elasticsearch<br>执行之后，会出现问题提示：</p><pre><code>Exception in thread &quot;main&quot; java.lang.RuntimeException: don&apos;t run elasticsearch as root.    at org.elasticsearch.bootstrap.Bootstrap.initializeNatives(Bootstrap.java:93)    at org.elasticsearch.bootstrap.Bootstrap.setup(Bootstrap.java:144)    at org.elasticsearch.bootstrap.Bootstrap.init(Bootstrap.java:285)    at org.elasticsearch.bootstrap.Elasticsearch.main(Elasticsearch.java:35)    Refer to the log for complete error details. </code></pre><p>– 4.解决办法</p><p>需要创建elasearch用户和用户组<br>创建组： groupadd elasearch<br>创建对应的用户： useradd elasearch -g elasearch -p rootsearch<br>回到elasticsearch-2.3.4的上级目录执行以下命令：<br>chown -R elasearch:elasearch elasticsearch-2.3.4/<br>切换到elasearch用户： su elasearch<br>进入bin目录执行 ：./elasticsearch -d<br>成功后，执行命令： curl localhost:9200,结果如下：</p><pre><code>{&quot;name&quot; : &quot;Thog&quot;,&quot;cluster_name&quot; : &quot;elasticsearch&quot;,&quot;version&quot; : {&quot;number&quot; : &quot;2.3.4&quot;,&quot;build_hash&quot; : &quot;e455fd0c13dceca8dbbdbb1665d068ae55dabe3f&quot;,&quot;build_timestamp&quot; : &quot;2016-06-30T11:24:31Z&quot;,&quot;build_snapshot&quot; : false,&quot;lucene_version&quot; : &quot;5.5.0&quot;},&quot;tagline&quot; : &quot;You Know, for Search&quot;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;– 1.检查jdk安装&lt;/p&gt;
&lt;p&gt;执行命令：java -version&lt;br&gt;如果有java相关信息，说明已经安装。&lt;br&gt;如果没有安装的话，执行命令：yum -y install  java-1.8.0-openjdk&lt;br&gt;– 2.下载elasticsearch安装
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>互联网+和+互联网的理解</title>
    <link href="http://caixw.cn/2018/04/29/20180429/"/>
    <id>http://caixw.cn/2018/04/29/20180429/</id>
    <published>2018-04-29T10:34:20.000Z</published>
    <updated>2018-04-30T14:32:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>近年，“互联网+”成为了一个热门词，涌现出了很多互联网+企业，比如“互联网+零售”成就了淘宝和京东，“互联网+信息”成就了谷歌和百度、“互联网+内容”成就了乐视和优酷。现在“互联网+”已经被提升到了国家战略的高度、国务院也制定了“互联网+”行动计划，催生了各行各业的“互联网+”创新大潮。但是，如今的BATJ等互联网巨头已经非常强大，单一的“互联网+平台”模式很难生存和发展空间；相反，很多传统企业由于有实体和渠道支撑，业务向互联网延伸和模式创新就相对容易很多，因此，“+互联网”也就是“传统企业+互联网”成为了新的方向和潮流。但是传统企业互联网转型存在人才、技术及运营模式等方面的短板和不足，在转型的过程中，会遇到各种问题和挑战；因此需要搭建一个平台，通过这个平台实现互联网转型企业间的“分享、交流、合作”，即让转型成功的典范企业分享成功经验和问题挑战，转型企业之间能够通过这个平台进行更直接的交流和更有效的沟通，通过交流找到彼此之间的业务合作机会，从而促成这些企业之间的跨界合作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近年，“互联网+”成为了一个热门词，涌现出了很多互联网+企业，比如“互联网+零售”成就了淘宝和京东，“互联网+信息”成就了谷歌和百度、“互联网+内容”成就了乐视和优酷。现在“互联网+”已经被提升到了国家战略的高度、国务院也制定了“互联网+”行动计划，催生了各行各业的“互联网
      
    
    </summary>
    
    
  </entry>
  
</feed>
